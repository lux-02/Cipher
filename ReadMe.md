# CIPHER

암호화: C=Ek(P)

복호화: P=Dk(C)

대칭 암호: Key 동일

비대칭 암호: 공개 Key로 암호화, 개인 Key로 복호화

키 공간 (Key Space): 해독 가능성, 확률 범위

시저 암호: 평행 이동으로 암호화(Shift) → 전사 공격(Brute Force) 가능

단일 치환 암호: 치환 테이블로 암호화 → 빈도 분석 공격 가능 (최빈도에 따른 패턴 분석)

애니그마: 날짜별 키가 기록된 코드북으로 암호화

- 통신키 암호화 → 설치 순서 및 각도
- 통신문 암호화 → 설치 각도

일회용 패드: 평문 XOR 랜덤 비트 (ASCII 부호화 XOR 랜덤 비트열)

⇒ 복호화해도 올바른 평문인지 판정하는게 불가능 → 그렇기 때문에 해독할 수 없다.

DES: 평문을 64bit 블록으로 나눔 → 각각의 블록을 DES로 암호화(Key 56bit)

1. L - 32bit / R - 32bit
2. R → F(k1) → L XOR R(Fk1)
3. L XOR R ⇒ 64bit
4. 3회 반복 ⇒ Festel Network 3Round

⇒ CPA 선택 평문 공격 가능 (단, 해독자가 임의의 평문을 암호화할 수 있다는 전제하에 가능)

Triple-DES

- DES-EDE2: 암호화(k1) → 복호화(k2) → 암호화(k1)

* 1, 3번째 키 동일

- DES-EDE3: 암호화(k1) → 복호화(k2) → 암호화(k3)

* Key가 다 다름

AES: Rijndael

---

Block 암호화: 집합 형태의 블록에 대해 각각 암호화하는 방식
평문을 블록화하고, 공간이 남으면 패딩 추가
(DES: 64bit / AES: 128, 192, 256bit)
Stream 암호화: 1, 8, 32bit씩 순차적으로 처리하는 방식

- IV = Initialize Vector (난수 블록)

DES Mode

- ECB (Electric Code Book)
  재전송 공격 가능 1. P1 → 암호화 → C1 2. P2 → 암호화 → C2 3. P3 → 암호화 → C3 4. P4 → 암호화 → C4
- CBC (Cipher Block Chaining) / 권장
  암호문 블록을 XOR하고 암호화 1. P1 [XOR] IV → 암호화 → C1 2. P2 [XOR] C1 → 암호화 → C2 3. P3 [XOR] C2 → 암호화 → C3 4. P4 [XOR] C3 → 암호화 → C4
- CFB (Cipher Feed Back)
  암호문 블록을 암호화한 후 XOR
  재전송 공격 가능 1. IV → 암호화 → C0 2. P1 [XOR] (C0 → 암호화) → C1 3. P2 [XOR] (C2 → 암호화) → C2 4. P3 [XOR] (C3 → 암호화) → C3 5. P4 [XOR] (C4 → 암호화) → C4
- OFB (Output Feed Back) \* 스트림 암호
  초기 암호화 블록을 계속 암호화하여 사용
  비트 반전 공격 가능 1. IV → 암호화 → X0 2. P1 [XOR] (X0 → 암호화 → X1) → C1 3. P2 [XOR] (X1 → 암호화 → X2) → C2 4. P3 [XOR] (X2 → 암호화 → X3) → C3 5. P4 [XOR] (X3 → 암호화 → X4) → C4
- CTR (Counter) \* 스트림 암호 / 권장
  카운터 값에 +1씩 증가시켜 암호화 수행
  비트 반전 공격 가능 1. P1 [XOR] (Counter+1 → 암호화 → X1) → C1 2. P2 [XOR] (Counter+2 → 암호화 → X2) → C2 3. P3 [XOR] (Counter+3 → 암호화 → X3) → C3 4. P4 [XOR] (Counter+4 → 암호화 → X4) → C4

키 전달 방식

- KDC: 키 배포 센터에서 일시적인 세션키를 공유하는 방식
  센터 과부하 및 센터 공격 - 중앙집중화의 단점
- Diffie-Hellman: 정보 교환 후 동일 키 생성 (공개키 방식)

공개 키 암호 방식:

- 암호화 키는 공개되어 있어서 누구나 암호화 가능, 복호화 키는 특정 개인만 가지고 있음

1. Key Pair = K(pub) / K(pri) 생성
2. K(pub) 전송 → C = E[K(pub), P] 암호화
3. P = D[K(pri), C] 복호화

시계 계산

- 덧셈: (A + B) MOD 12
- 뺄셈: (A + X) MOD 12 = 0 → X 계산
- 곱셈: (A \* B) MOD 12
- 나눗셈: (A \* X) MOD 12 = 1 → X 계산

MOD 12에서 역수를 갖는 수는 1, 12 이외의 공통 약수를 가지지 않는 수이다.

⇒ 1, 5, 7, 11

7^4 MOD 12 = 1

RSA

⇒ E = P^E MOD N → 공개키 E, N

⇒ P = C^D MOD N → 개인키 D, N

1. 2개의 소수 p, q 선택
2. N ⇒ p \* q
3. L ⇒ lcm(p-1, q-1)
   L은 키 쌍 생성에만 사용, p-1과 q-1의 최소공배수
4. E ⇒ gcd(E, L) = 1
   E와 L은 서로소 관계, 1<E<L
5. D ⇒ E \* D mod L = 1
   1<D<L

예시

1. p=17, q=19
2. N = 17 \* 19 = 323
3. L = lcm(16, 18) = 144
4. E = gcd(E, 144) = 1 → E = 5, 7, 11, 13, 17 …
   E = 5로 선택
5. D ⇒ 5 \* D mod 144 = 1 → D = 29

그러므로 공개키(E, N) = (5, 323) , 개인키(D, N) = (29, 323)

암호문을 평문으로 복호화하기 위해선 공개된 N을 기준으로 p, q 소수를 구해야 하므로,
고속으로 소인수분해 할 수 있는 방법이 있다면 RSA를 깰 수 있다.

중간자 공격

A가 B에게 공개키를 요청할 때,

C가 B의 공개키를 가지고, A에게 C의 공개키를 전달

A가 C의 공개키로 암호화한 평문을 B에게 전달

C가 중간에서 탈취 후 평문 확보, 다시 B의 공개키로 암호화하여 B에게 전달

공개키 방식은 같은 정도의 기밀성을 갖는 키 길이의 경우, 대칭 암호보다 몇 백배나 느림

긴 메시지를 암호화하기에 적합하지 않으며 중간자 공격에 약하기 때문에 대칭암호 방식과 병행하여 사용

하이브리드 암호 - PGP, SSL/TLS

C1 = E[K, P] → 대칭 암호화 메시지 → 복호화시 P = D(K, C1)

C2 = E[K(pub), K] 공개키 암호화 세션키 → 복호화시 개인키 K(pri) 필요 K = D[K(pri), C2]

C = C1 || C2 = E[K, P] || E[K(pub), K]

대칭 암호 및 공개키 암호 키길이는 양쪽 같은 정도의 강도가 되도록 밸런스 맞추기

장기간 운용시 대칭 암호보다 공개키 암호를 강하게 해야함

---

## One-way Hash Func.

파일의 무결성을 조사하기 위해 해시 값(메시지 다이제스트)을 비교하는 방법

- Input: Message
- Output: Hash Value (입력값의 길이와 관계없이 고정된 길이 출력)

입력되는 숫자를 23으로 나누어 몫을 소수로 표현 → 소숫점 이하 7자리 ~ 10자리 4개

Ex) 345689 / 23 = 15029.956521**7391**3043 … ⇒ 7391

일방향성 ⇒ 메시지에서 해시값 추출은 간단하나, 해시값에서 메시지 값을 추출하는 것은 불가능하다. (pre-image: 해시값에서 원본값을 찾는 공격)

Collision ⇒ 2개의 다른 메시지가 같은 해시 값을 가지는 것

충돌 내성 ⇒ h(x) = h(y)가 발생하면 안된다.

- 약한 충돌 내성: x를 알고 있는 상태에서 동일 해시값을 가지는 y를 찾기 어려워야 함
- 강한 충돌 내성: 둘 다 모르는 상태에서 충돌이 발생하는 x, y 쌍을 찾기 어려워야 함

활용

- 소프트웨어 변경 검출
- PBE 비밀번호 암호화 키
  (패스워드 + Salt → 해시 값 추출 → 암호화 키)
- MAC 메시지 인증 코드
  (비밀 키 → 내부 키, 외부 키 해싱 → 인증 코드)
- 디지털 서명
- PRNG 의사난수 생성
  (예측 불가능성 증가)

## SHA-512

- 입력: 최대 2^128bit 메시지
- 출력: 512bit 고정 메시지 다이제스트
- 1,024bit 블록 처리
- 충돌 안전성
  - 약 충돌성: 2^256
  - 강 충돌성: 2^512

### **단계 1: 메시지 패딩**

1. **원래 메시지에 '1' 비트 추가**:
   - 메시지 끝에 단일 '1' 비트를 추가합니다. 예를 들어, 메시지가 **`101010`**라면, 이를 **`1010101`**로 만듭니다.
2. **'0' 비트 추가**:
   - 메시지의 길이가 896비트가 될 때까지 '0' 비트를 추가합니다. 896비트는 최종 블록의 마지막 128비트를 메시지의 원래 길이를 저장하는 데 사용하기 위해 예약된 것입니다.
3. **메시지 원래 길이 추가**:
   - 원래 메시지의 길이를 비트 단위로 128비트로 표현하여 최종 블록의 끝에 추가합니다.

### **단계 2: MD 버퍼 초기화**

SHA-512는 8개의 64비트 워드로 구성된 초기 해시 값(H0~H7)으로 시작합니다. 이 초기 값은 다음과 같이 정의됩니다:

```python
python코드 복사
H = [
    0x6a09e667f3bcc908, 0xbb67ae8584caa73b,
    0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
    0x510e527fade682d1, 0x9b05688c2b3e6c1f,
    0x1f83d9abfb41bd6b, 0x5be0cd19137e2179
]

```

### **단계 3: 80 라운드 처리**

SHA-512 알고리즘은 각 1024비트 메시지 블록을 80 라운드에 걸쳐 처리합니다. 각 라운드는 다음 단계를 포함합니다:

1. **메시지 스케줄 준비**:

   - 메시지 블록을 80개의 64비트 워드(W[0] ~ W[79])로 확장합니다. 초기 16개의 워드는 입력 블록에서 직접 복사되고, 나머지 64개는 다음과 같이 생성됩니다:

     ```python
     for t in range(16, 80):
         s0 = (rightrotate(W[t-15], 1) ^ rightrotate(W[t-15], 8) ^ (W[t-15] >> 7))
         s1 = (rightrotate(W[t-2], 19) ^ rightrotate(W[t-2], 61) ^ (W[t-2] >> 6))
         W[t] = (W[t-16] + s0 + W[t-7] + s1) & 0xffffffffffffffff

     ```

2. **작업 변수 초기화**:
   - 8개의 워드를 작업 변수로 초기화합니다:
     ```python
     a, b, c, d, e, f, g, h = H
     ```
3. **주 라운드**:

   - 각 라운드마다 다음 연산을 수행합니다:

     ```python
     for t in range(80):
         S1 = (rightrotate(e, 14) ^ rightrotate(e, 18) ^ rightrotate(e, 41))
         ch = (e & f) ^ ((~e) & g)
         temp1 = (h + S1 + ch + K[t] + W[t]) & 0xffffffffffffffff
         S0 = (rightrotate(a, 28) ^ rightrotate(a, 34) ^ rightrotate(a, 39))
         maj = (a & b) ^ (a & c) ^ (b & c)
         temp2 = (S0 + maj) & 0xffffffffffffffff

         h = g
         g = f
         f = e
         e = (d + temp1) & 0xffffffffffffffff
         d = c
         c = b
         b = a
         a = (temp1 + temp2) & 0xffffffffffffffff

     ```

4. **중간 해시 값 업데이트**:
   - 각 블록 처리가 끝날 때마다 중간 해시 값을 업데이트합니다:
     ```python
     H = [(H[i] + var) & 0xffffffffffffffff for i, var in enumerate([a, b, c, d, e, f, g, h])]
     ```

### **단계 4: 최종 해시 값 출력**

모든 메시지 블록에 대해 위 과정을 반복한 후, 최종 해시 값은 8개의 64비트 워드를 결합하여 512비트(64바이트)로 출력됩니다.

## SHA-3 / KECCAK

SHA-3 (Secure Hash Algorithm-3)

NIST에서 경쟁방식에 의한 표준화 방식으로 선정

SHA-3: 2012년 KECCAK 알고리즘 선정

SHA-2는 입력 메시지를 고정된 크기의 블록으로 나누고, 각 블록은 1 시작 0으로 채우는 패딩 방식이 적용되어 압축 함수로 처리하여 중간 해시 값을 갱신하는 방식이었으나, SHA-3는 스펀지 구조를 기반으로, 흡수 단계와 짜내기 단계로 구성된다. 입력 메시지를 r-bit 청크로 나누고, 각 청크 내부에서 XOR 연산으로 흡수한다. 내부 상태는 f 함수에 의해 반복적으로 변환되고, 멀티 레이트 패딩을 사용하여 필요한 만큼 0비트를 추가하고 메시지 끝에 1비트 추가한다.

KECCAK는 **Sponge 구조**를 사용하여 데이터를 처리합니다.

Sponge 구조는 데이터를 흡수하고 짜내는 두 가지 주요 단계를 통해 해시 값을 생성한다.

### **1. Sponge 구조**

- **흡수 단계 (Absorbing)**:
  - 입력 데이터를 작은 청크로 나눕니다.
  - 각 청크는 내부 상태에 XOR 연산을 통해 흡수됩니다.
  - 내부 상태는 1600비트(5x5x64 비트)로 구성됩니다.
  - 각 청크가 흡수될 때마다 내부 상태는 특정 함수(f 함수)에 의해 변환됩니다.
- **짜내기 단계 (Squeezing)**:
  - 모든 입력 데이터가 흡수된 후, 내부 상태로부터 해시 값을 짜내기 시작합니다.
  - 필요한 길이의 해시 값을 얻을 때까지 내부 상태를 반복적으로 변환하고 데이터를 짜냅니다.

### **2. 내부 상태**

- KECCAK의 내부 상태는 5x5 크기의 그리드 형태로, 각 칸은 64비트 길이를 가집니다.
- 전체 내부 상태는 1600비트로 구성됩니다.

### **3. f 함수**

- f 함수는 여러 변환 단계를 통해 내부 상태를 복잡하게 만듭니다.
- 주요 변환 단계는 _θ_, _ρ_, _π_, _χ_, _ι_ 입니다.

### **주요 변환 단계**

1. **_θ_ (Theta)**:
   - 각 칸의 값을 주변 칸들과 혼합합니다.
   - 이를 통해 내부 상태의 각 비트가 전체 상태에 걸쳐 고르게 분포되도록 합니다.
2. **_ρ_ (Rho)**:
   - 각 칸의 값을 특정 횟수만큼 회전시킵니다.
   - 각 비트는 고유한 회전량을 가지고 있습니다.
3. **_π_ (Pi)**:
   - 비트 위치를 재배열합니다.
   - 3차원 비트 배열의 각 비트는 새로운 위치로 이동합니다.
4. **_χ_ (Chi)**:
   - 각 칸의 값을 동일한 행의 다른 두 칸의 값과 결합합니다.
   - 비트 논리 연산을 통해 새로운 값을 생성합니다.
5. **_ι_ (Iota)**:
   - 특정 라운드마다 고유한 상수를 내부 상태에 더합니다.
   - 각 라운드는 서로 다른 방식으로 변환됩니다.

## MAC 메시지 인증 코드

1. 송금자는 은행에 키를 공유하고, 송금 의뢰 메시지 MAC 계산 값 전송
2. 은행은 송금 의뢰 메시지에 대해 키를 통해 MAC 계산 후 전송 받은 MAC 계산 값과 비교
3. 동일하면 인증 성공

활용사례

- SWIFT : 은행 간 거래 메시지 교환
- IPsec : IP 프로토콜에 보안 기능 추가 (통신 내용 인증, 무결성)
- SSL/TLS : 통신 프로토콜 (통신 내용 인증, 무결성)

구현 방법

- HMAC: SHA-1, MD5와 같은 일방향 해시함수 이용
  키 패딩 → ipad XOR → 메시지 결합 → 해시 값 계산
  키 패딩 → opad XOR → 해시 값 결합 → 해시 값 계산
- Triple-DES, AES 같은 블록 암호를 사용하는 방법
  1. 블록 암호 키를 공유키로 사용
  2. CBC 모드로 메시지 전체를 암호화
  3. 최종 블록을 MAC 값으로 이용

인증 암호

- Encrypt-than-MAC
  평문 → 대칭 암호 암호화 → 암호문 MAC 값 계산
- Encrypt-and-MAC
  평문 → 대칭 암호 암호화 → 평문 MAC 값 계산
- MAC-then-Encrypt
  평문 MAC 값 계산 → 평문 및 MAC 값 대칭 암호로 암호화

공격

- 재전송 공격 → 저장해둔 MAC 값을 반복 송신하여 동일 작업 수행
  - 순서 번호를 붙이기
  - 타임스탬프 적용
  - 일회용 랜덤 비표 값을 합쳐서 MAC 계산
- 키 추측 공격(전사공격, 생일공격) → MAC 값으로 키 추측
  - 해시 함수의 일방향성, 충돌내성, 의사난수생성기 사용
- 제3자에게 증명 불가능 → 메시지 출처에 대한 증명이 불가능하며, 부인 방지 불가

## 디지털 서명

개인이 가진 서명용 키(개인키)로 서명하고, 검증용 키(공개키)로 누구나 검증할 수 있다.

⇒ 공개 키 암호 방식을 역으로 사용함

디지털 서명은 기밀성을 지키기 위한 것이 아니다.

아무리 서명을 복사해도 그 메시지에 누가 서명했는가는 변하지 않기 때문에 무의미하다.

메시지와 서명 내용을 수정하면 서명 검증에 실패하기 때문에 수정 검출이 가능하다.

서명 작성은 송신자만 가능하므로, 부인방지가 가능하다.

활용

- 클리어서명 : 메시지 암호화 없이 서명만 하여 보안 공지에 사용
- 소프트웨어 다운로드 : 다운로드 후 내용 조작 검출 가능
- 공개 키 인증서 : 공개키를 메시지로 간주하고 서명을 붙인 것
- SSL/TLS : 서버 공개키에 서명하여 서버가 올바른지 확인

RSA 서명 작성

- 개인키 = D, N

- 공개키 = E, N

서명 = (Message)^D mod N

검증 = (Sign)^E mod N

공격

- 중간자 공격
  공개 키가 정확한지 확인 필요 → 핑거프린트(해시 값) 사용하여 방어
- 충돌내성
- 교묘한 속임수
  공개키로 암호화 한 암호문에 서명하면 복호화 된다.
- 잠재적 위조
  ⇒ RSA-PSS (Probabilistic Signature Scheme)
  메시지가 아닌 메시지 해시 값에 대해 서명

메시지 인증 코드와 디지털 서명의 차이점

⇒ 메시지 인증 코드는 송신자와 수신자 모두 공유 키로 MAC 값을 계산하지만,

디지털 서명은 송신자는 개인 키로 서명을 작성하고, 수신자는 공개 키로 서명을 검증한다.

하이브리드 암호 시스템과 해시 값에 대한 디지털 서명의 차이점

대칭 암호 키는 기밀성, 해시 값은 무결성이 핵심이다.

## 인증서

### **공개 키 인증서 (PKC)**

1. 수신자는 키 쌍을 작성하고, 공개 키를 트렌트에 등록
2. 트렌트는 공개 키를 개인 키로 디지털 서명하여 인증서 작성
3. 트렌트의 디지털 서명되어 있는 공개키 입수
4. 송신자는 트렌트의 공개키를 사용하여 서명을 검증하고, 공개 키 확인
5. 공개 키로 메시지 암호화하여 송신
6. 암호문을 개인 키로 복호화 하여 메시지 확인

표준 규격: X.509

인증서 생성 및 교환 시 사용

### 공개 키 기반 구조 (PKI)

- 이용자
  - 공개 키를 등록하고 싶은 사람
    키 쌍을 작성한 후, 인증기관에 공개 키 등록 → 인증서 발행
    수신한 암호문 복호화, 메시지에 디지털 서명
  - 등록된 공개 키를 사용하고 싶은 사람
    메시지 암호화 및 송신
    디지털 서명 검증
- 인증기관
  인증서 관리(인증서 작성 및 발행, 폐지)
  공개 키 등록 때 본인 인증
  국내 최상위 인증기관: KISA
- 등록기관(RA)
  공개 키 등록 및 본인 인증 대행 기관
- 저장소(repository)
  인증서 보존 데이터베이스

공격

- 공개 키 등록 이전 공격
  서명 전에 공개 키를 바꿔치기 하는 공격
- 비슷한 사용자 정보를 이용하여 거짓행세
- 인증기관의 개인 키를 도난 ⇒ CRL을 사용해 이용자에게 통지
- 공격자 자신이 인증기관이 되어 인증서를 자유롭게 발행

신뢰할 수 없는 경로로 공개키를 입수하는 것보다,

인증기관으로부터 인증서 입수시 중간자 공격 가능성 감소

## 난수

- 무작위성 : 수열이 무작위로 구성
- 예측 불가능성 : 다음 수 예측 불가
- 재현 불가능성 : 같은 수열 재현 불가

**선형 합동법**

의사난수 값을 A배 하고 C를 더한 다음 M으로 나눈 나머지를 다음 의사난수로 채택

의사난수 값은 반드시 0부터 M-1 범위를 가진다.

A, C, M 값에 따라 다른 주기를 가진다.

예측 불가능성이 없기 때문에 암호기술에 사용해서는 절대 안된다.

R0 = (A x Seed + C) mod M

R1 = (A x R0 + C) mod M

Rn+1 = (A x Rn + C) mod M

암호를 사용하면 암호의 기밀성이 의사난수 생성기의 예측 불가능성을 보장한다.

공격

- 시드 공격
  시드가 노출되면 모든 의사난수열은 공격자에게 노출된다.
  ⇒ 재현 불가능성을 갖는 진정한 난수를 선택해야 한다.
  ⇒ 랜덤 풀 (랜덤 비트열을 사전에 만들어 놓은 파일) 사용

## PGP (Pretty Good Privacy)

암호 소프트웨어

- 대칭 암호 및 공개 키 암호에 대한 암호화, 복호화 지원
- 디지털 서명 지원
- 일방향 해시 함수 계산
- 인증서 작성

- **암호화**:
  - 대칭 키 생성: 송신자가 임의의 대칭 키를 생성합니다.
  - 메시지를 대칭키로 암호화: 대칭 키를 사용하여 메시지를 암호화합니다.
  - 대칭 키를 공개키로 암호화: 수신자의 공개 키를 사용하여 대칭 키를 암호화합니다.
  - 암호화된 메시지 전송: 암호문과 암호화된 대칭 키를 전송합니다.
- **복호화**:
  - 대칭 키를 개인키로 복호화: 수신자가 자신의 개인 키를 사용하여 암호화된 대칭 키를 복호화합니다.
  - 암호문을 대칭키로 복호화: 복원된 대칭 키를 사용하여 암호문을 복호화합니다.

## TLS 핸드쉐이크

1. **클라이언트 헬로**: 클라이언트가 서버에 "Hello" 메시지를 보냅니다.
2. **서버 헬로**: 서버가 클라이언트에 "Hello" 메시지를 응답합니다.
3. **서버 인증서 전송**: 서버가 자신의 인증서를 클라이언트에게 보냅니다.
4. **서버 헬로 완료**: 서버가 클라이언트에게 "ServerHelloDone" 메시지를 보냅니다.
5. **클라이언트 키 교환**: 클라이언트가 프리마스터 시크릿을 생성하여 서버에 보냅니다.
6. **클라이언트 완료**: 클라이언트가 "Finished" 메시지를 보냅니다.
7. **서버 완료**: 서버가 "Finished" 메시지를 보냅니다.
8. **안전한 통신 시작**: 클라이언트와 서버는 세션 키를 사용하여 안전하게 통신합니다.
